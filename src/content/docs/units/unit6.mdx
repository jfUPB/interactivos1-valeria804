---
title: Unidad 6
unitId: unit6
---

import ActivityPlaceholder from '../../../components/ActivityPlaceholder.astro';
import unidades from '../../activities/unidades.json';
import { Aside} from '@astrojs/starlight/components';

export const unit = unidades.find(u => u.nombre === frontmatter.title);

## Introducci칩n 游닆
<Aside type="note" title=" ">

춰Felicidades por llegar a la sexta unidad! Ya dominas t칠cnicas para conectar 
dispositivos f칤sicos a aplicaciones interactivas usando comunicaci칩n serial 
(ASCII y binaria). Ahora, vamos a dar un paso m치s all치 y explorar c칩mo conectar 
dos aplicaciones que se ejecutan en tu navegador en tiempo real.

En esta unidad, descubrir치s Node.js y Socket.IO, herramientas poderosas que nos 
permitir치n crear un "puente" de comunicaci칩n. Node.js actuar치 como un servidor 
intermediario, y Socket.IO facilitar치 el env칤o y recepci칩n de mensajes instant치neos 
entre las aplicaciones cliente (sketches de p5.js). Empezaremos analizando un caso 
de estudio funcional para entender la mec치nica servidor-cliente y luego lo 
modificar치s para crear tu propia experiencia interactiva conectada. Aunque en esta 
unidad ambas aplicaciones cliente correr치n en tu computador, esto sienta las bases 
para futuras conexiones entre diferentes dispositivos o computadores.
</Aside>

## 쯈u칠 aprender치s en esta unidad? 游눠

<Aside type="tip" title=" ">
- Configurar치s y ejecutar치s un servidor b치sico usando Node.js, Express y Socket.IO.  
- Implementar치s comunicaci칩n en tiempo real entre dos sketches de p5.js utilizando 
Socket.IO a trav칠s de un servidor Node.js.  
- Analizar치s la arquitectura cliente-servidor y el flujo de datos en una aplicaci칩n 
web en tiempo real.  
- Modificar치s un caso de estudio existente para crear una nueva aplicaci칩n 
interactiva que utilice comunicaci칩n en red.  
- Comparar치s esta forma de comunicaci칩n con la comunicaci칩n serial vista en 
unidades anteriores.
</Aside>

{unit.actividades
  .filter(act => act.fase === "set")
  .map(act => (
    <ActivityPlaceholder 
      id={act.nombre.replace('actividad','activity').replace('.md', '')} 
      unit={frontmatter.unitId} 
    />
  ))
}

## Investigaci칩n 游댍

<Aside type="note" title=" ">
Ahora que has visto el caso de estudio en acci칩n, es momento de investigar c칩mo funciona 
internamente. Nos centraremos primero en el "puente" (el servidor Node.js) y luego en 
c칩mo los clientes (los sketches p5.js) interact칰an con 칠l. Este caso de estudio est치 inspirado 
en el trabajo de [Sahand Babali](https://youtu.be/cBgxArOP4jg?si=--bM5_oR1LcF9RVQ) y explora 
conceptos similares a los vistos en la obra [Entangled](https://x.com/_nonfigurativ_/status/1727322594570027343) 
de Bj칮rn Staal.
</Aside>

{unit.actividades
  .filter(act => act.fase === "seek")
  .map(act => (
    <ActivityPlaceholder 
      id={act.nombre.replace('actividad','activity').replace('.md', '')} 
      unit={frontmatter.unitId}
    />
  ))
}

## Aplicaci칩n 游

<Aside type="note" title=" ">
Has analizado c칩mo funciona la comunicaci칩n bidireccional en tiempo real entre dos 
sketches de p5.js usando Node.js y Socket.IO. Ahora es tu turno de tomar este 
conocimiento y aplicarlo creativamente.
</Aside>

{unit.actividades
  .filter(act => act.fase === "apply")
  .map(act => (
    <ActivityPlaceholder 
      id={act.nombre.replace('actividad','activity').replace('.md', '')} 
      unit={frontmatter.unitId} 
    />
  ))
}

## Consolidaci칩n y metacognici칩n 游뱂

<Aside type="note" title=" ">
Hemos cubierto bastante terreno en esta unidad, introduciendo un nuevo paradigma de 
comunicaci칩n. Es hora de reflexionar sobre lo aprendido.
</Aside>

{unit.actividades
  .filter(act => act.fase === "reflect")
  .map(act => (
    <ActivityPlaceholder 
      id={act.nombre.replace('actividad','activity').replace('.md', '')} 
      unit={frontmatter.unitId} 
    />
  ))
}