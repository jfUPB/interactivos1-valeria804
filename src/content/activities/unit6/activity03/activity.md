#### El Servidor (Node.js)

:::note[üéØ **Enunciado**]
Vamos a analizar paso a paso el archivo server.js. Este script es el n√∫cleo que 
permite la comunicaci√≥n en tiempo real. No te preocupes si ves c√≥digo nuevo, iremos explicando cada parte.
:::

##### 1. Dependencias: las herramientas necesarias

``` js
// server.js
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');
const path = require('path');
```

:::note[üß© **Explicaci√≥n**]
Estas l√≠neas importan m√≥dulos (librer√≠as) que Node.js necesita.

* express: es un framework popular para construir servidores web de forma m√°s sencilla. Nos ayuda a manejar las peticiones de los navegadores.

* http: es el m√≥dulo base de Node.js para crear servidores HTTP. Express lo usa por debajo.

* socket.io: ¬°La estrella de la comunicaci√≥n en tiempo real! Permite enviar mensajes bidireccionales instant√°neos entre el servidor y los clientes (navegadores).

* path: una utilidad para trabajar con rutas de archivos y directorios de forma segura en cualquier sistema operativo.
:::

:::caution[üßê‚úçÔ∏è Reflexiona]
¬øPor qu√© crees que es √∫til usar m√≥dulos o librer√≠as en lugar de escribir todo desde cero? ¬øQu√© ventajas aporta? Anota tus ideas en la bit√°cora.
:::

##### 2. Creaci√≥n del Servidor y Socket.IO

``` js
const app = express();
const server = http.createServer(app); 
const io = socketIO(server); 
const port = 3000;
```

:::note[üß© **Explicaci√≥n**]

* app = express(): creamos una instancia de la aplicaci√≥n Express. app ser√° nuestro objeto principal para configurar el servidor web.

* server = http.createServer(app): creamos un servidor HTTP est√°ndar y le decimos que use nuestra aplicaci√≥n app de Express para gestionar las peticiones.

* io = socketIO(server): ¬°Aqu√≠ conectamos Socket.IO! Le decimos que ``"escuche"`` en nuestro servidor HTTP (server). Ahora io nos permitir√° manejar las conexiones de Socket.IO.

* port = 3000: definimos la variable port con el n√∫mero 3000. Es el n√∫mero de puerto en el que nuestro servidor escuchar√° las conexiones entrantes.
:::

##### 3. Variables para guardar el estado

``` js
let page1 = { x: 0, y: 0, width: 100, height: 100 };
let page2 = { x: 0, y: 0, width: 100, height: 100 };
```

:::note[üß© **Explicaci√≥n**]
Estas variables globales (page1, page2) las usar√° el servidor para recordar la 
√∫ltima informaci√≥n (posici√≥n y tama√±o) que recibi√≥ de cada cliente (ventana del navegador). 
Se inicializan con valores por defecto.
:::

##### 4. Sirviendo los archivos del cliente

``` js	
// Sirve archivos est√°ticos (HTML, CSS, JS del cliente) desde la carpeta 'views'
app.use(express.static(path.join(__dirname, 'views')));
```

:::note[üß© **Explicaci√≥n**]
Esta l√≠nea es importante. Le dice a Express que, si un navegador pide un archivo 
(como page1.js o style.css), lo busque dentro de la carpeta views. ``__dirname`` es una variable 
especial de Node.js que representa la ruta absoluta de la carpeta donde se encuentra 
server.js, y path.join la une de forma segura con views.
:::

:::caution[üßêüß™‚úçÔ∏è Experimenta]

- Det√©n el servidor (Ctrl+C en la terminal).

- Cambia la l√≠nea a app.use(express.static(path.join(__dirname, 'archivos_cliente'))); 
(usa un nombre de carpeta que no exista).

- Inicia el servidor (npm start) y trata de abrir http://localhost:3000/page1.html 
en el navegador.

- ¬øQu√© ocurre? ¬øPor qu√©? ¬øQu√© mensaje ves en el navegador o en su consola 
de desarrollador (F12)?

- Vuelve a dejar la l√≠nea como estaba ('views') y verifica que funcione de nuevo. Anota tus observaciones.
:::


##### 5. Rutas: Qu√© enviar cuando se pide una URL

``` js
// Define la ruta para servir page1.html
app.get('/page1', (req, res) => {
    res.sendFile(path.join(__dirname, 'views', 'page1.html'));
});

// Define la ruta para servir page2.html
app.get('/page2', (req, res) => {
    res.sendFile(path.join(__dirname, 'views', 'page2.html'));
});
```

:::note[üß© **Explicaci√≥n**] 
Estas funciones definen qu√© debe hacer el servidor cuando un navegador solicita las URLs /page1 o /page2. app.get le dice a Express que escuche peticiones GET para esas rutas. Cuando llega una petici√≥n, ejecuta la funci√≥n asociada:

res.sendFile(...): Env√≠a el archivo HTML correspondiente (page1.html o page2.html) de vuelta al navegador. De nuevo, path.join construye la ruta completa al archivo.
:::

:::caution[üßêüß™‚úçÔ∏è Experimenta]

- Det√©n el servidor.

- Cambia la primera ruta de /page1 a /pagina_uno.

- Inicia el servidor.

- Intenta acceder a http://localhost:3000/page1. ¬øFunciona?

- Ahora intenta acceder a http://localhost:3000/pagina_uno. ¬øFunciona?

- ¬øQu√© te dice esto sobre c√≥mo el servidor asocia URLs con respuestas? Restaura el c√≥digo.
:::


##### 6. ¬°La Magia de Socket.IO! La Conexi√≥n

``` js
// Evento principal de Socket.IO: se dispara cuando un cliente se conecta
io.on('connection', (socket) => {
    console.log('A user connected - ID:', socket.id); // Muestra el ID √∫nico del cliente conectado

    // (Aqu√≠ dentro ir√°n los manejadores de eventos para ESE cliente)

    // Evento: se dispara cuando ESE cliente se desconecta
    socket.on('disconnect', () => {
        console.log('User disconnected - ID:', socket.id);
    });
});
```

:::note[üß© **Explicaci√≥n**] 
Esta es la parte central de Socket.IO en el servidor.

io.on('connection', ...): Establece un ``"oyente"`` para el evento connection. Este evento 
se dispara cada vez que un nuevo cliente (una ventana del navegador con page1.js o page2.js) 
establece una conexi√≥n de Socket.IO con el servidor.

La funci√≥n que se ejecuta recibe un par√°metro important√≠simo: socket. Este objeto socket 
representa la conexi√≥n individual con ese cliente espec√≠fico. Cada cliente tendr√° su 
propio objeto socket.

socket.id: es un identificador √∫nico que Socket.IO asigna a cada conexi√≥n. √ötil para saber 
qui√©n se conecta o desconecta.

socket.on('disconnect', ...): dentro del oyente de connection, establecemos otro oyente 
espec√≠fico para ese socket. Este se dispara cuando ese cliente en particular se desconecta 
(cierra la pesta√±a, pierde conexi√≥n, etc.).
:::


:::caution[üßêüß™‚úçÔ∏è **Experimenta**]

- Aseg√∫rate de que el servidor est√© corriendo (npm start).

- Abre http://localhost:3000/page1 en una pesta√±a. Observa la terminal del servidor. ¬øQu√© mensaje ves? Anota el ID.

- Abre http://localhost:3000/page2 en OTRA pesta√±a. Observa la terminal. ¬øQu√© mensaje ves? ¬øEl ID es diferente?

- Cierra la pesta√±a de page1. Observa la terminal. ¬øQu√© mensaje ves? ¬øCoincide el ID con el que anotaste?

- Cierra la pesta√±a de page2. Observa la terminal.
:::


##### 7. Escuchando Mensajes de los Clientes

``` js
// Dentro de io.on('connection', (socket) => { ... });

    // Evento: escucha mensajes 'win1update' enviados desde page1.js
    socket.on('win1update', (window1, sendid) => {
        console.log('Received win1update from ID:', socket.id, 'Data:', window1); // Log para ver qu√© llega
        page1 = window1; // Actualiza la informaci√≥n del estado de page1 en el servidor
        
        // Env√≠a la informaci√≥n actualizada de page1 a TODOS los dem√°s clientes conectados
        socket.broadcast.emit('getdata', page1); 
    });

    // Evento: escucha mensajes 'win2update' enviados desde page2.js
    socket.on('win2update', (window2, sendid) => {
        console.log('Received win2update from ID:', socket.id, 'Data:', window2); // Log para ver qu√© llega
        page2 = window2; // Actualiza la informaci√≥n del estado de page2 en el servidor
        
        // Env√≠a la informaci√≥n actualizada de page2 a TODOS los dem√°s clientes conectados
        socket.broadcast.emit('getdata', page2);
    });
```

:::note[üß© **Explicaci√≥n**] 
Estos bloques tambi√©n van dentro de io.on('connection', ...) 
porque definen c√≥mo debe reaccionar el servidor a mensajes de un cliente 
espec√≠fico (socket).

socket.on('win1update', ...): escucha un evento llamado 'win1update'. 
Esperamos que el cliente page1.js env√≠e este tipo de mensaje. 
Cuando llega, se ejecuta la funci√≥n.

window1, sendid: son los datos que el cliente env√≠a junto con el evento (veremos esto en page1.js). 
window1 contiene la informaci√≥n de posici√≥n/tama√±o.

console.log(...): a√±adimos un log para ver qu√© datos llegan y de qui√©n.

page1 = window1;: actualizamos la variable global del servidor con los datos frescos 
recibidos de page1.

socket.broadcast.emit('getdata', page1);: ¬°La retransmisi√≥n!

broadcast: significa "a todos menos a m√≠" (al socket que envi√≥ el mensaje original).

emit('getdata', page1): env√≠a un nuevo mensaje llamado 'getdata' a todos los dem√°s 
clientes, llevando consigo la informaci√≥n actualizada de page1.

El bloque socket.on('win2update', ...) es sim√©trico, pero para los mensajes que vienen de page2.js.
:::

:::caution[üßêüß™‚úçÔ∏è **Experimenta**]

- Aseg√∫rate de que los console.log que a√±adimos est√©n presentes en tu server.js.

- Inicia el servidor y abre page1 y page2.

- Mueve la ventana de page1. Observa la terminal del servidor. ¬øQu√© evento se registra 
(win1update o win2update)? ¬øQu√© datos (Data:) ves?

- Mueve la ventana de page2. Observa la terminal. ¬øQu√© evento se registra ahora? ¬øQu√© datos ves?

- Experimento clave: cambia socket.broadcast.emit('getdata', page1); por 
socket.emit('getdata', page1); (quitando broadcast). Reinicia el servidor, abre ambas p√°ginas. 
Mueve page1. ¬øSe actualiza la visualizaci√≥n en page2? ¬øPor qu√© s√≠ o por qu√© no? 
(Pista: ¬øA qui√©n le env√≠a el mensaje socket.emit?). Restaura el c√≥digo a broadcast.emit.
:::

##### 8. Poner en marcha el Servidor

``` js
// Inicia el servidor y lo pone a escuchar en el puerto especificado
server.listen(port, () => {
    console.log(`Server is listening on http://localhost:${port}`);
});
```

:::note[üß© Explicaci√≥n] 
Esta es la l√≠nea final que efectivamente inicia el servidor.

server.listen(port, ...): le dice al servidor HTTP que empiece a escuchar conexiones en el port que definimos (3000).

La funci√≥n () => { ... } es un callback que se ejecuta una vez que el servidor se ha 
iniciado correctamente y est√° listo para aceptar conexiones. Simplemente imprime un mensaje √∫til en la consola.
:::


:::caution[üßêüß™‚úçÔ∏è Experimenta]

- Det√©n el servidor.

- Cambia const port = 3000; a const port = 3001;.

- Inicia el servidor. ¬øQu√© mensaje ves en la consola? ¬øEn qu√© puerto dice que est√° escuchando?

- Intenta abrir http://localhost:3000/page1. ¬øFunciona?

- Intenta abrir http://localhost:3001/page1. ¬øFunciona?

- ¬øQu√© aprendiste sobre la variable port y la funci√≥n listen? Restaura el puerto a 3000.
:::

:::caution[üì§ Entrega]
Revisa tu bit√°cora. Deber√≠as tener anotaciones y reflexiones para cada uno de los 
8 puntos y los experimentos asociados al servidor. Aseg√∫rate de entender el flujo: 
recibir conexi√≥n -> escuchar eventos del cliente -> actualizar estado -> retransmitir a 
otros clientes.

